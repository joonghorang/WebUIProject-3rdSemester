5장 데이터 

d3로 돔구조에 엘리먼트 추가하기 
ex)
d3.select("body").append("p").text("New paragraph!");
바디를 찾고 p태그를 추가한뒤, 내용으로 "New paragraph"를 넣는다. 

* d3는 좀 심하다 싶을 정도로 체인 문법이란 기법을 사용한다. 
구두점(.)과 함께 메서드를 체인처럼 연결함으로써 코드 한 줄에 여러 동작을 실행할 수 있는 기법이다. 
이는 쉽고 빠르지만, 그냥 사용하면 안되고 동작원리를 이해해야한다. 

일단 함수와 메서드는 사실 동일 개념에 대한 다른 표현일 뿐이다. 
즉, 인자입력을 허용하면서 어떤 동작을 수행하고 결과 정보를 반환하는 코드 덩어리를 뜻한다. 

따라서 위의 코드는 가독성 있게 표현해보면 
d3.select("body")
	.append("p")
	.text("New paragraph!");

이제 하나씩 분석해보자. 
d3 는 
D3 객체를 참조해서 D3의 메서드를 사용할 수 있게 한다. D3의 모든 코드는 이렇게 시작한다. 

.select("body")
이 메서드는 조건과 일치하는 첫 번째 DOM 문서요소의 참조를 반환한다. 

.append("p")
전달인자로 받은 DOM문서 요소를 새로 생성해서, 앞 체인에서 선택한 문서요소가 무엇이든 그 끝(안쪽에)에 추가한다. 
여기서는 p문서요소를 새로 생성해서 body안에 추가했다.  
append()는 생성된 p를 다시 뒤따라오는 메서드로 넘겨준다. 

.text("New paragraph!")
text()메서드는 전달 인자로 문자열을 받아서 해당 선택문의 여는 태그와 닫는 태그 사이에 추가한다. 
바로 전 메서드에서 새로운 p문서요소의 참조를 전달받았으므로 이 코드는 <p>와 </p>사이에 텍스트를 추가한다. 
(이미 텍스트가 들어있으면 덮어버린다.)

세미콜론(;)
체인 연결이 끝났다는 뜻이다. 

* 대부분의 D3메서드는 메서드 체이닝 기법을 적용할 수 있도록 결과 값으로 선택물을 반환한다. (실제로는 선택물의 참조를 반환한다)
그래서 메서드를 체인으로 연결할 때는 그 순서가 중요하다는 사실을 명심해야 한다. 
어떤 메서드의 반환값 타입은 체인으로 연결된 다음 메서드가 기대하는 입력 값에 들어맞아야 한다. 

D3 API 레퍼런스는 각 메서드가 무엇을 기대하고 무엇을 반환하는지 찾는 데 도움이 된다. 
http://github.com/mbostock/d3/widi/API-Reference

만약 체인문법을 사용하지 않는다면 다음과 같이 표현된다. 
var body = d3.select("body");
var p = body.append("p");
p.text("New paragraph!");

이 경우는 연결해야 할 함수가 너무 많거나 할때 적절하다. 

이제 D3로 문서요소를 생성하는 법을 배웠으니 거기에 데이터를 더하는 법을 살펴보자. 

데이터 시각화란 "데이터를 시각 요소로 연결하는 과정"이다.  
다르게 표현하면 데이터가 입력값이고 시각 요소의 속성이 출력값이다. 

데이터를 엮기 위해선 다음 두 가지가 필요하다. 
1. 데이터
	1.1 커스텀데이터 
		ex) var data = [ 5, 10, 15];
	
	1.2 CSV
		ex)
		var dataset;

		d3.csv("food.csv", function(data){ // 첫번째 인자는 CSV파일을 불러올 경로를 나타내는 문자열, 두 번째 인자는 콜백함수로 사용될 익명함수 
											// 콜백함수는 d3.csv()가 완전히 끝난 뒤 실행된다. 
			dataset = data;

			// 시각화를 생성하는 함수들 돌림. 
			console.log(data);
		});

		*d3.csv()는 비동기 메서드다. 따라서 콜백함수 밖에서 불러올 csv를 참조하면 안된다. 그런 작업은 콜백함수안에서 하는 것이 좋다.  
	
	1.3 JSON
		ex)
		d3.json("waterfall.json", function(data){
			console.log(data); // 콘솔에 json읽은걸 출력  
		})

2. DOM 문서요소 선택물 
	이제 선택자로 DOM에서 무엇을 선택해야할지 결정해야 한다.
	그런데 어떤 문서요소가 데이터와 관련이 있을까? 

	d3.select("body").selectAll("p");

	하지만, 우리가 선택하길 원하는 p 태그는 현재 DOM에 존재하지 않는다. 

	"어떻게 존재하지 않는 문서요소를 선택할 수 있을까?"

	해답은 enter()메서드에 있는데, 다음 예를 보면

	d3.select("body")		// body를 찾아서 넘김 
		.selectAll("p")		// p를 모두 선택, 하지만 지금은 존재하지 않기 때문에 빈 선택물을 반환 
		.data(dataset)		// 데이터 값이 몇 개인지 계산하고 파싱한다. 이 메서드 다음에 체인으로 연결된 모든 내용은 값마다 한 번씩 즉, 5개의 값이 있으면 총 5번 실행된다. 
		.enter()			// 해당 DOM 선택물이 있는지 살펴보고 데이터를 건네준다. 관련 DOM문서요소보다 데이터 값이 많으면 enter()메서드는 여러분이 마법을 부릴 수 있는 
							// 플레이스 홀더 역할을 할 문서요소를 생성한다. 그리고 체인으로 연결된 다음 메서드를 위해서 생성한 플레이스 홀더의 참조 값을 넘긴다. 
		.append("p")		// 앞서 생성한 빈 플레이스 홀더 선택물을 가져와서 DOM에 p문서 요소를 추가한다. 
		.text("New paragraph!"); // 새로 만든 p의 참조를 가져와서 그곳에 텍스트 값을 넣는다. 

	이렇게 데이터를 연결하면, 해당 엘리먼트의 속성값중 __data__ 속성에 들어가 있다.
	즉 그 데이터는 DOM에 존재하지 않고 문서요소의 __data___ 속성으로 메모리에 존재한다.  

데이터를 엮었으니 이제 사용해보자. 

좀전의 코드중에 .text() 메서드 부분만 아래와 같이 수정해보면
text(function(d) {return d;}); 
각 단락에 들어갈 내용으로 데이터를 선택한 것이다. 
모든 건 data()메서드가 마법을 부린 덕이다. 메서드가 체인으로 연결되어 있을 때 
데이터를 받는 'd'변수를 사용할 수 있다. 이를 응용해서 익명함수를 만드는 것이다. 

이 변수는 항상 익명함수로 감싸지 않으면 사용할 수 없다. 
전달인자가 함수가 아니면 D3가 해당 데이터값을 참조할 수 없기 때문이다. 
익명함수와 전달인자 없이 d로 값을 받으려 하면, D3는 "당황하며 울상이된다" 


D3에서는 많은 익명 함수를 사용한다. 익명함수는 데이터에 접근하고 프로퍼티를 동적으로 변경하는 핵심 역할을 맡는다. 
또한 익명함수는 원하는 대로 변경할 수 있다. 
그래서 익명함수는 천국과 지옥을 오가는 통로가 되기도 한다. 

다시 위의 코드중에
.style("color", "red");
를 추가하면 CSS 프로퍼티를 변경할 수 있다. 
D3의 장점은 여기에서 익명함수를 적용해 특정 개체의 스타일만 바꿀 수 있는데 
ex)
.style("color", function(d){
	if (d > 15){
		return "red";
	} else {
		return "black";
	}
});

자 이제 데이터를 드로잉할 준비가 되었다.
(으아아...)