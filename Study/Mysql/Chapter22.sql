22장 고급 데이터 조작 옵션 

제약 조건 이해하기 

관계형 데이터베이스는 데이터를 여러 테이블에 나누어 저장하고, 
각 테이블은 관련된 데이터를 가진다. 

한 테이블과 다른 테이블을 연결할 때는 키를 사용한다.(그래서 참조 무결성이라는 용어를 사용한다.)

관계형 데이터 베이스 설계가 제대로 작동하려면, 유효한 데이터만이 테이블에 삽입된다고 보장할 수 있는 방법이 필요하다. 

이를 클라이언트에서 확인하는 것은 시간이 많이 소요되는 방법이기 때문에, 
DBMS가 확인하는 것이 효율적이다. 

DBMS에서의 제약조건은 대부분 테이블을 생성할 때 정의된다.(CREATE TABLE 이나 ALTER TABLE)
* 제약 조건은 DBMS 마다 다를 수 있다. 


주키 

주 키는 특별한 제약조건으로 컬럼(또는 컬럼집합)에 있는 값이 고유하면서 절대 변하지 않는다는 것을 보장하기 위해 사용된다. 
다음 조건만 만족하면 어떤 컬럼이던 주 키로 설정할 수 있다. 

- 두 개 이상의 행이 같은 주 키 값을 가질 수 없다. 
- 모든 행은 주 키 값을 반드시 가져야한다.(NULL 허용안됨)
- 주 키 값을 가진 컬럼은 변경되거나 업데이트될 수 없다.
- 주 키 값은 절대 재사용되어서는 안된다. 테이블에서 행이 삭제되더라도, 그 값이 다른 새로운 행에 재할당 되어서는 안된다. 

주 키의 정의법 중 하나는 테이블을 생성할 때 정의하는 것이다. 
ex)
CREATE TABLE Vendors
(
	vend_id		CHAR(10)	NOT NULL PRIMARY KEY
);

또는 이미 만들어진 테이블을 변경하여 정의할 수도 있다.  
ALTER TABLE Vendors
ADD CONTRAINT PRIMARY KEY(vend_id);

외래 키 
외래 키(Foreign Key)는 테이블에 있는 컬럼이면서 다른 테이블의 주 키로 정의된 컬럼이다. 
외래 키는 고유할 필요가 없다.
이를 정의하는 방법은 REFERENCES 키워드를 사용하면 된다. 
ex)
CREATE TABLE Orders
(
	order_num		INTEGER		NOT NULL PRIMARY KEY,
	order_date 		DATETIME	NOT NULL,
	cust_id			CHAR(10)	NOT NULL REFERENCES Customers(cust_id)
);
* 여기서 cust_id 값은 반드시 Customers 테이블에 존재해야한다. 

또는 이미 만들어진 테이블을 변경할 수도 있는데, 
ALTER TABLE Orders
ADD CONTRAINT
FOREIGN KEY(cust_id) REFERENCES Customers(cust_id);

고유 키 무결성 제약 조건 
이는 컬럼(또는 컬럼집합)에 있는 모든 데이터가 동일한 값을 가질 수 없음을 제약하는 조건이다. 
주 키와 비슷하지만, 몇 가지 차이가 있다. 

- 테이블은 여러 고유 키 무결성 제약 조건을 가질 수 있지만, 
주 키는 한 테이블에 하나만 설정되어야 한다. 
- 고유 키 무결성 제약 조건 컬럼은 NULL 값을 가질 수 있다. 
- 고유 키 무결성 제약 조건 컬럼은 변경되거나 업데이트 될 수 있다. 
- 고유 키 무결성 제약 조건 컬럼의 값은 재사용될 수 있다. 
- 주 키와는 달리 고유 키 무결성 제약 조건은 외래 키로 정의되어 사용될 수 없다. 

*예를 들어 주민등록번호는 너무 길고, 보안상의 이유로 주키로 사용하지 않는다. 
이런 상황에서 주민등록번호 컬럼에 고유 키 무결성 제약 조건을 정의하면 된다. 

이걸 거는 방법은 테이블을 정의할 때 UNIQUE 키워드를 사용하거나 CONTRAINT를 사용하면 된다. 


체크 무결성 제약 조건 
이는 컬럼에서 허용 가능한 데이터의 범위나 조건을 지정하기 위한 제약 조건이다. 

용도
- 최소 값이나 최대 값 확인(주문이 0이 될 수 없다. 0이 유효한 값이더라도)
- 범위 지정(배송 날짜는 오늘이거나 오늘 이후여야 하고, 현재 날짜에서 1년 이내여야한다.)
- 특정 값만 허용(성별 필드에 M과 F만 가능하다)

이는 데이터 베이스에 원하는 값만 삽입되는 것을 보장하는 역할을 한다. 

ex)
CREATE TABLE OrderItems
(
quantity 	INTEGER 	NOT NULL CHECK (quantity > 0)
);

이 제약 조건으로 새로운 행이 삽입되거나 업데이트 될 때 quantity가 0보다 큰지 확인한다. 

또는 존재하는 테이블을 변경할 수도 있는데
ex)
ADD CONTRAINT CHECK (gender LIKE '[MF]')
M이나 F만 입력받는다. 


인덱스 이해하기 
인덱스는 데이터를 논리적으로 정렬해 검색과 정렬 작업 속도를 높이는 데 사용한다. 

찾아보기의 원리는 무엇일까? 
간단히 말해, 올바른 정렬에 있다. 
책에서 단어를 찾을 때 힘든 이유는 찾아야 하는 내용의 양이 많아서가 아니라,
내용이 단어 순서대로 정렬되지 않았기 떄문이다. 
사전처럼 내용이 정렬되어 있다면, 찾아보기는 필요하지 ㅇ낳ㄴ다(그렇기 때문에 사전에는 찾아보기가 없다!)

데이터베이스 인덱스는 매우 비슷한 원리로 동작한다.
주 키 데이터는 항상 정렬되어 있어서, 주 키로 특정 데이터를 가져오는 것은 언제나 빠르면서 동시에 효율적이다. 
하지만, 주키 외의 다른 컬럼으로 값을 찾아야할 때도 있는데 이 때 인덱스를 사용한다. 
하나 이상의 컬럼을 인덱스로 정의할 수 있는데,
인덱스로 정의한 컬럼은 DBMS가 내용을 정렬해서 저장해 놓는다. 
인덱스가 정의되면, DBMS는 책의 찾아보기를 사용할 때와 거의 비슷한 방식을 사용한다. 

이 인데스를 사용하는 구문은
ex)
CREATE INDEX prod_name_ind
ON PRODUCTS(prod_name)

*모든 인덱스는 고유한 이름을 가져야 한다. 


트리거 이해하기 
트리거는 특정한 데이터베이스 작업이 발생하면 자동으로 수행되는 특별한 저장 프로시저로,
특정한 테이블에 INSERT, UPDATE, DELETE 작업이 일어나면 자동으로 실행되는 코드이다. 
SQL 구문을 저장하는 저장 프로시저와는 달리,
트리거는 테이블과 묶여서 동작한다. 

트리거에서는 다음과 같은 데이터에 접근할 수 있다. 
-INSERT 작업으로 추가된 데이터
-UPDATE작업으로 처리한 이전 데이터와 새로운 데이터 
-DELETE작업으로 삭제된 데이터 

트리거의 일반적인 용도는 다음과 같다. 
- 데이터 일관성 보장(INSERT나 UPDATE작업이 수행될 때 모든 도시명을 대문자가 되게 한다)
- 테이블의 변화를 감지하여 특정한 작업을 수행(행이 업데이터되거나 삭제될 때마다 로그 테이블에 기록한다)
- 추가적인 데이터 유효성 검사나 데이터 롤백 수행(고객의 신용한도가 초과되었는지 확인하고, 초과한 경우 데이터 추가를 막는다)
- 계산형 컬럼 값을 계산하거나 날짜/시간형 데이터를 업데이트 

트리거 생성 문법은 DBMS마다 현저하게 다르다. 

ex)
CREATE TRIGGER customer_state
ON Customers
FOR INSERT, UPDATE
AS
UPDATE Customers
SET cust_state = Upper(cust_state)
WHERE Customers.cust_id = inserted.cust_id;
